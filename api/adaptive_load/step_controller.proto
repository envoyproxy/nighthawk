syntax = "proto3";

package nighthawk.adaptive_load;

import "google/protobuf/any.proto";

// Identifies a simple field or other hard-coded aspect of the Nighthawk
// CommandLineOptions.
enum SimpleNighthawkField {
  UNKNOWN_FIELD = 0;
  REQUESTS_PER_SECOND = 1;
  NUMBER_OF_CONNECTIONS = 2;
  CONCURRENCY = 3;
  BURST_SIZE = 4;
  MAX_PENDING_REQUESTS = 5;
  MAX_ACTIVE_REQUESTS = 6;
  MAX_REQUESTS_PER_CONNECTION = 7;
  // Vary the length of the URI using the form "/aaaaa".
  URI_LENGTH = 8;
  // Vary the length of a single header x-nighthawk-adaptive-load with the value
  // in the form "aaaaa".
  HEADER_SIZE = 9;
  // Add a variable number of small headers named x-nighthawk-adaptive-load-# to
  // the request.
  HEADER_COUNT = 10;
  // Vary the size of the request body consisting of "aaaaa" (note: subject to
  // Nighthawk limits).
  REQUEST_BODY_SIZE = 12;
  // Response size requested from a Nighthawk Test Server via a header.
  RESPONSE_SIZE = 12;
}

// Specifies any Envoy fault injection filter header that takes a numerical
// value. See
// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/fault_filter.
message FaultInjectionHeader {
  // Name of any numeric Envoy fault injection header.
  string header_name = 1;
}

// Identifies a some numerical aspect of the Nighthawk CommandLineOptions proto
// that the StepController should vary, in pursuit of the optimal field value.
// For example, for the basic case of finding the optimal RPS, the simple_field
// would be REQUESTS_PER_SECOND. Enables the same StepController algorithm to be
// used to find the optimal RPS, optimal concurrency, etc.
message NighthawkInputVariableSpec {
  oneof selector {
    SimpleNighthawkField simple_field = 1;
    FaultInjectionHeader fault_injection_header = 2;
  }
}

// Selects and configures a StepController plugin.
message StepControllerConfig {
  // Name used to locate the plugin in the Envoy registry.
  string name = 1;
  // Plugin-specific config.
  google.protobuf.Any typed_config = 2;
}
