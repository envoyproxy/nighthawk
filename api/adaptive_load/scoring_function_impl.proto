// Plugin-specific config protos for ScoringFunction plugins.

syntax = "proto3";

package nighthawk.adaptive_load;

import "google/protobuf/wrappers.proto";

// Configuration for BinaryScoringFunction (plugin name: "nighthawk.binary") that is 1.0
// when the value is within thresholds and -1.0 otherwise.
message BinaryScoringFunctionConfig {
  // The minimum allowed value of the metric. Optional, default -infinity.
  google.protobuf.DoubleValue lower_threshold = 1;
  // The maximum allowed value of the metric. Optional, default infinity.
  google.protobuf.DoubleValue upper_threshold = 2;
}

// Configuration for LinearScoringFunction (plugin name: "nighthawk.linear") that
// calculates a metric score as k * (threshold - value), where k is a scaling
// constant. The score is 0.0 when the value exactly equals the threshold,
// positive below the threshold (meaning input should ramp up), and negative
// above the threshold. The score is proportional to the difference from the
// threshold.
message LinearScoringFunctionConfig {
  // The target value of the metric. Required.
  double threshold = 1;
  // Scaling constant: k in k * (threshold - value). Use this in combination
  // with step controller constants to produce reasonable input increments for
  // reasonable differences from the threshold. Required.
  double k = 2;
}

// Configuration for SigmoidScoringFunction (plugin name: "nighthawk.sigmoid") that
// calculates a metric score as 1 - 2 / (1 + exp(-k(value - threshold))), an
// upside-down sigmoid curve centered on a threshold. The output is 0.0 when the
// metric equals the threshold, approaches 1.0 for values far below the
// threshold, and approaches -1.0 for values far above the threshold.
message SigmoidScoringFunctionConfig {
  // The target value of the metric. Required.
  double threshold = 1;
  // Tuning constant: k in 1 - 2 / (1 + exp(-k(value - threshold))). k should
  // be around the same size as 1/threshold. Required.
  double k = 2;
}
