syntax = "proto3";

package nighthawk.adaptive_rps;

import "api/adaptive_rps/benchmark_result.proto";
import "api/adaptive_rps/metrics_plugin.proto";
import "api/adaptive_rps/metric_spec.proto";
import "api/adaptive_rps/step_controller.proto";
import "api/client/options.proto";
import "google/protobuf/duration.proto";
import "google/rpc/status.proto";
import "validate/validate.proto";

// Parameters describing the adjusting and testing stages of an adaptive RPS
// session, which consists of a series of Nighthawk benchmarks probing for
// the optimal RPS, followed by a longer benchmark to validate the optimal RPS.
// RPS calculations are implemented by the selected StepController plugin.
// Metrics can eb
message AdaptiveRpsSessionSpec {
  // Settings for MetricsPlugins that obtain metrics from outside sources.
  // An entry is required for every plugin referred to by metric_thresholds,
  // other than the "builtin" plugin.
  repeated MetricsPluginConfig metrics_plugin_configs = 1;
  // Metrics and thresholds that determine RPS adjustments.
  repeated MetricSpecWithThreshold metric_thresholds = 2 [(validate.rules).repeated .min_items = 1];
  // Metrics that are collected and included in the output but not taken into
  // account when adjusting the RPS.
  repeated MetricSpec informational_metric_specs = 3;
  // A proto describing Nighthawk Service traffic. See
  // https://github.com/envoyproxy/nighthawk/blob/master/api/client/options.proto
  //
  // The adaptive RPS controller will return an error if the |duration|,
  // |requests_per_second|,  or |open_loop| fields are set within
  // |nighthawk_traffic_options|; the controller sets these values dynamically.
  //
  // All other fields in |nighthawk_traffic_options| are passed through to the
  // Nighthawk Service.
  //
  // Note that |concurrency| in |nighthawk_traffic_options| multiplies the total
  // RPS sent.
  nighthawk.client.CommandLineOptions nighthawk_traffic_template = 4;
  // The duration of each short benchmark during the adjusting stage. Must be
  // set. O(10 seconds).
  google.protobuf.Duration measuring_period = 5 [(validate.rules).duration.gt.seconds = 0];
  // Maximum amount of time the adjusting stage should wait for convergence
  // before returning an error. O(300 seconds).
  google.protobuf.Duration convergence_deadline = 6 [(validate.rules).duration.gt.seconds = 0];
  // The duration of the single benchmark session of the testing stage to
  // confirm the performance at the RPS found by the adjusting stage. Must be
  // set.
  google.protobuf.Duration testing_stage_duration = 7 [(validate.rules).duration.gt.seconds = 0];
  // Selects and configures a StepController plugin.
  StepControllerConfig step_controller_config = 8;
}

// Complete description of an adaptive RPS session, including metric evaluations
// for every RPS value attempted during the adjusting stage.
message AdaptiveRpsSessionOutput {
  // Overall status of the session with error detail.
  google.rpc.Status session_status = 1;
  // Results of each short benchmark performed during the adjusting stage.
  repeated BenchmarkResult adjusting_stage_results = 2;
  // Result of the single benchmark of the testing stage.
  BenchmarkResult testing_stage_result = 3;
}
